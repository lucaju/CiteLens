package view.reader.readerScroll {		//imports	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Rectangle;		import flashx.textLayout.events.TextLayoutEvent;		import view.reader.AbstractReader;	import view.reader.MainReader;
			/**	 * Scroll Class.	 *  	 * @author lucaju	 * 	 */	public class ReaderScroll extends Sprite{				//****************** Properties ****************** ****************** ******************				protected var _hTotal			:Number = 0;							//Total height if vertical		protected var _hMax				:Number = 0;							//Max height if vertical				protected var rate				:Number;				protected var _hasRoll			:Boolean = true;				protected var _target			:AbstractReader;						//Target scrolled object		protected var roll				:Roll;									//Roll		protected var track				:Track;									//Track				protected var _color			:uint = 0x000000;						//Color.						//****************** Constructor ****************** ****************** ******************				/**		 * [Exclude(name="Sprite", kind="method")] 		 * Constructor.		 * <p>You have to set some attributes to make the scroll works</p>		 * <p>Required:</p>		 * <p>TARGET: Set the target using the function target.</p> 		 * <br />		 * <p>Optional:</p>		 * <p>COLOR: Set Roll and Track colors usinf the function color. The default is 0x000000 (Black).</p>		 * 		 * <p>The construct add an event. Whenever it is added to the screen, it will add the other iteractive events.</p>		 */		public function ReaderScroll() {			this.addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);		}						//****************** INITIALIZE ****************** ****************** ******************				/**		 * 		 * 		 */		public function init():void {						roll = new Roll();			roll.init();;			this.addChild(roll);			roll.height = hMax / rate;						this.y = target.y;			this.x = target.width - this.width;			roll.addEventListener(MouseEvent.MOUSE_DOWN, _startDrag);		}						//****************** PROTECTED METHODS ****************** ****************** ******************				/**		 * Add Events at the momment that it is added to the stage		 * @param e:Event		 * 		 */		protected function addedToStageHandler(e:Event):void{			target.textFlow.addEventListener(TextLayoutEvent.SCROLL, scroll);		}				/**		 * Remove Scroll Event Listeners		 * 		 */		protected function removeEvents():void {			target.textFlow.removeEventListener(TextLayoutEvent.SCROLL, scroll);		}				/**		 * Rate Page: Calculate the page rate.		 * 		 * <p>It automatically calls scrollSize function.</p>		 */		protected function ratePage():void {			rate = hTotal / hMax;			scrollSize();		}				/**		 * Scroll Size: Resize roll and track.		 * 		 */		protected function scrollSize():void {				if (track) track.height = hMax;			if (roll) roll.height = hMax / rate;		}						//****************** PROTECTED EVENTS ****************** ****************** ******************				/**		 * 		 * @param event		 * 		 */		protected function scroll(event:TextLayoutEvent):void {			hTotal = target.getMaxHeight();			hMax = target.height;			ratePage();				if (roll) roll.y = target.getCurrentVerticalPosition() / rate;		}				/**		 * 		 * @param event		 * 		 */		protected function _startDrag(event:MouseEvent):void {			hTotal = target.getMaxHeight();			hMax = target.height;			ratePage();						var limit:Rectangle = new Rectangle(0,0,0,hMax-roll.height); //*			roll.startDrag(false,limit);						roll.removeEventListener(MouseEvent.MOUSE_DOWN, _startDrag);						stage.addEventListener(Event.ENTER_FRAME, _update);			stage.addEventListener(MouseEvent.MOUSE_UP, _stopDrag);			target.textFlow.removeEventListener(TextLayoutEvent.SCROLL, scroll);		}				/**		 * 		 * @param event		 * 		 */		protected function _update(event:Event):void {			hTotal = target.getMaxHeight();			hMax = target.height;			ratePage();						target.setVerticalPosition(roll.y * rate);		}				/**		 * 		 * @param event		 * 		 */		protected function _stopDrag(event:MouseEvent):void {			roll.stopDrag();						roll.addEventListener(MouseEvent.MOUSE_DOWN, _startDrag);						stage.removeEventListener(Event.ENTER_FRAME, _update);			stage.removeEventListener(MouseEvent.MOUSE_UP, _stopDrag);						target.textFlow.addEventListener(TextLayoutEvent.SCROLL, scroll);		}						//****************** PUBLIC METHODS ****************** ****************** ******************				/**		 * 		 * 		 */		public function update():void {			hTotal = target.getMaxHeight();			hMax = target.height;			ratePage();			scrollSize();		}				/**		 * getRatePage. Returns the current page rate in the scroll.		 * @return 		 * 		 */		public function getRatePageY():Number {			return rate;		}						//****************** GETTERS / /SETTERS ****************** ****************** ******************				/**		 * Target. Returns the current scroll target. 		 * @return 		 * 		 */		public function get target():AbstractReader {			return _target;		}				/**		 * Target: Set scroll target. 		 * 		 * @param		 * 		 */		public function set target(value:AbstractReader):void {			_target = value;			hTotal = target.getMaxHeight();			hMax = target.height;			ratePage();			}				/**		 * Color. Returns the current color used on Roll and Track objects. 		 * @return uint		 * 		 */		public function get color():uint {			return _color;		}						/**		 * Define Roll and Track colors.		 *  		 * @param value:uint		 * 		 */		public function set color(value:uint):void {			_color = value;		}				/**		 * 		 * @return 		 * 		 */		public function get hTotal():Number {			return _hTotal;		}				/**		 * 		 * @param value		 * 		 */		public function set hTotal(value:Number):void {			_hTotal = value;		}				/**		 * 		 * @return 		 * 		 */		public function get hMax():Number {			return _hMax;		}				/**		 * 		 * @param value		 * 		 */		public function set hMax(value:Number):void {			_hMax = value;		}		}}

